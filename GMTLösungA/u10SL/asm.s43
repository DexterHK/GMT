#include "msp430.h"                     ; #define controlled include file
LED1    EQU     BIT0
S2      EQU     BIT1
Reset   EQU     BIT1
LED2    EQU     BIT7
Delay  EQU      50000
MASK    EQU     11111111B
DelayEasy EQU   100
        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack
       
         BIC.B #0x01,&P6SEL              ;P6.0 (=A0) als I/O

         BIC.W #ADC12ENC,&ADC12CTL0      ;make sure conversion disabled
         MOV.W #ADC12ON, &ADC12CTL0      ; ADC12_A on
 
         ; clock source ADC12  |  Single-channel-single conversion  | divider 8
         MOV.W #ADC12SSEL_0 | ADC12CONSEQ_0 | ADC12DIV_0, &ADC12CTL1
         BIS.W #ADC12SHP, &ADC12CTL1            ; Sample-and-hold by time
        
         MOV.B #ADC12SREF_0, &ADC12MCTL0        ; Reference ACSS..AVCC
         BIS.B #ADC12INCH0, &ADC12MCTL0        ;Input Channel select A0
        
main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        
        
        BIS.B   #LED1,&P1DIR            ;Output
        BIC.B   #LED1,&P1OUT            ;Auschalten

        BIS.B   #LED2,&P4DIR            ;Output 
        BIC.B   #LED2,&P4OUT            ; Ausschalten

        BIC.B #S2,&P2DIR          ;If DIR 1 == Output, also 0 Input
        BIS.B #S2,&P2REN         ;IF Pull-Up oder Down = 1, Input without pull up or down = 0
        BIS.B #S2,&P2OUT         ;If 0 == Pull Down, 1 == Pull Up

        BIC.B #Reset,&P1DIR          ;If DIR 1 == Output, also 0 Input
        BIS.B #Reset,&P1REN         ;IF Pull-Up oder Down = 1, Input without pull up or down = 0
        BIS.B #Reset,&P1OUT         ;If 0 == Pull Down, 1 == Pull Up
        mov.B #0x0,R6                 ; How fast is the player
        mov.B #0x0,R7                ; Delay Counter
        MOV.B #0x0,R8                ;Carry Flag
        MOV.B 0x0,R9                 ;Easy Delay
         BIS.W #ADC12ENC, &ADC12CTL0  ;ADC12_A enable  conversion
         BIS.W #ADC12SC, &ADC12CTL0
        
TimerBusy:
        BIT.W #ADC12BUSY, &ADC12CTL1  ;ADC12_A busy?
        JNZ TimerBusy                 ;yes: check again
        MOV.W &ADC12MEM0, R5          ;no: copy conversion result to R5

WaitRandom:
       CALL #WaitingEasy
       DEC  R5
       JNZ WaitRandom

GrunOn:
        BIS.B   #LED2,&P4OUT          ; aufleuchten
PressButtonTwo:
        INC R6
        ADC R8
        BIT.B #S2, &P2IN  
        JNZ PressButtonTwo

Calculate:
       CMP.B #0x1,R8
       JGE Three
       CMP.W #010000000000000B,R6
       JGE One
       JMP Two

       
One:
      CALL #Light
      JMP WaitForReset

Two:
      CALL #Light
      CALL #Waiting
      CALL #Light
      JMP WaitForReset
   
      
Three:
      CALL #Light
      CALL #Waiting
      CALL #Light
      CALL #Waiting
      CALL #Light
      JMP WaitForReset
      
WaitForReset:
      BIT.B #Reset, &P1IN
      JNZ WaitForReset
      JMP Reseting
      
Reseting:
      mov #0x0,R6
      mov #0x0,R7
      mov #0x0,R8
      JMP TimerBusy
      

Waiting:
       INC.W  R7
       CMP.W #Delay,R7
       JNE   Waiting
       MOV.W #0x0,R7
       ret
      
Light:
      BIC.B  #LED2,&P4OUT            
      BIS.B  #LED1,&P1OUT            
      CALL   #Waiting
      BIC.B  #LED1,&P1OUT            ;Auschalten 
      ret
 
WaitingEasy:
       INC.W  R9
       CMP.W #DelayEasy,R9
       JNE   WaitingEasy
       MOV.W #0x0,R9
       ret



      

        

        END
